2.2 Inject dependencies and configuration values as constructor arguments
  Listing 2.1 The FileLogger service
  Listing 2.2 FileLogger has a dependency and needs a configuration value
  Listing 2.3 Using separate constructor arguments for username and password
  Listing 2.4 Username and password are now together in a Credentials object

2.3 Inject what you need, not where you can get it from
  Listing 2.5 A simplified implementation of a service locator
  Listing 2.6 Using a ServiceLocator to retrieve dependencies
  Listing 2.7 Injecting the actual dependencies as constructor arguments
  Listing 2.8 The actual dependency is UserRepository, not EntityManager

2.4 All constructor arguments should be required
  Listing 2.9 Logger as an optional constructor argument
  Listing 2.10 The client doesn’t have to provide a value for logFilePath
  Listing 2.11 The default value for logFilePath is hidden in log()

2.5 Only use constructor injection
  Listing 2.12 A Logger can be provided later by calling setLogger ()

2.6 There’s no such thing as an optional dependency
  Listing 2.13 An implementation of the Logger interface that does nothing
  Listing 2.14 A default Configuration object can easily be obtained

2.7 Make all dependencies explicit
  Listing 2.15 Inject a Cache instance instead of using its static methods
  Listing 2.16 JsonEncoder wraps the json_encode() call
  Listing 2.17 MeetupRepository depends on the current time
  Listing 2.18 Clock can be used to retrieve the current time
  Listing 2.19 A Clock implementation where time is fixed
  Listing 2.20 You can also pass the current time as a method argument
2.8 Task-relevant data should be passed as method arguments instead of constructor arguments
  Listing 2.21 An EntityManager that can only be used to save a single object
  Listing 2.22 ContactRepository depends on a Session object
  Listing 2.23 entity should be a method argument
  Listing 2.24 UserId and CompanyId should be passed as method arguments

2.9 Don’t allow the behavior of a service to change after it has been instantiated
  Listing 2.25 Calling ignoreErrors() changes the behavior of Importer
  Listing 2.26 The behavior of EventDispatcher can change after instantiation
  Listing 2.27 Listeners can only be configured at construction time

2.10 Do nothing inside a constructor, only assign properties
  Listing 2.28 FileLogger creates a log file directory if necessary
  Listing 2.29 The constructor of FileLogger doesn’t create the directory
  Listing 2.30 The LoggerFactory will create the log file directory
  Listing 2.31 LoggerFactory takes care of everything FileLogger needs
  Listing 2.32 Mailer does something inside its constructor
  Listing 2.33 Changing the order of assignments in the Mailer constructor

2.11 Throw an exception when an argument is invalid
  Listing 2.34 Alerting requires an int constructor argument
  Listing 2.35 Validate a constructor argument before assigning it
  Listing 2.36 Router doesn’t throw an exception
  Listing 2.37 Router should validate the controllers array
  Listing 2.38 An alternative for validating the controllers array
2.12 Define services as an immutable object graph with only a few entry points
  Listing 2.39 Public methods for entry points, private ones for dependencies


